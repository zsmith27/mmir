---
title: "Metric Sensitivity with mmir"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
author: Zachary M. Smith
---
`r format(Sys.Date(), "%m-%d-%Y")`

# Overview

This document was created to provide an example of how to calculate metric sensitivity when developing an MMI or IBI using the __mmir__ R-package.

# Preparation

Install the __tidyverse__ packages developed by R Studio. This is a collection of packages that make it easier to import, manipulate, and plot data. You will also need to install the __DT__ package if you want to create the interactive tables found below.
```{r, messages=FALSE, warning=FALSE}
#install.packages("tidyverse")
suppressPackageStartupMessages(
  library(tidyverse)
  )
```

Install the Multi-Metric Index (MMI) package, __mmir__, that I am developing from Git Hub. The package, __devtools__, must be installed to use the `install_github()` function. Make sure you install the development version (`ref = "dev"`).
```{r, eval=FALSE}
devtools::install_github("zsmith27/mmir", ref = "dev", force = TRUE, quiet = TRUE)
```

Once __mmir__ is installed, load the packages with `library()`.
```{r}
library(mmir)
```

__mmir__ contains my thesis data, _onondaga_, as an example data set.
```{r}
data("onondaga")
```

Calculate example metrics.
```{r}
metrics.wide <- onondaga %>% 
  select(unique_id, lake) %>% 
  distinct() %>% 
  bind_cols(taxa_seq(onondaga, unique_id, reporting_value, c("order", "family"), "final_id",  job = "rich"),
            taxa_seq(onondaga, unique_id, reporting_value, c("order", "family"),  job = "pct"))

DT::datatable(metrics.wide, options = list(scrollX = TRUE))
```

# Calculate Metric Sensitivity


## Long Data Transformation

Most likely your metrics are stored in a wide data format (see `metrics.wide`); however, to simplify the metric sensitivity calculations the data needs to be transformed to a long data format. This can be easily done with the __tidyr__ (installed and loaded with __tidyverse__) function, `gather()`.
```{r}
metrics.long <- gather(metrics.wide, metric, value, 3:ncol(metrics.wide))

DT::datatable(metrics.long)
```

## Calculate Metric Sensitivity

Barbour et al. (1996) created a visual method for evaluating metric response to a defined disturbance gradient.

* 0 = The medians of both the reference and degraded conditions overlap the interquartile range of one another.
* 1 = One median (either the reference or degraded) overlaps the interquartile range of the other.
* 2 = The interquartile ranges of the reference and degraded conditions overlap but neither conditions median overlaps with the interquartile range of the other category.
* 3 = The interquartile ranges of the reference and degraded conditions do not overlap.

Discrimination Efficiency (DE) is a measure of the percentage of degraded samples correctly identified below the reference distributions 25th percentile for metrics that decrease with degradation or the percentage of degraded samples correctly identified above the reference distributions 75th percentile for metrics that increase with disturbance.

Balanced Discrimination Efficiency (BDE) attempts to update the DE method by throwing more computation power at the problem. BDE tests multiple thresholds for separating the reference and degraded distributions in an attempt to find the best separation point.

Use the `sensitivity()` function to calculate three types of metric sensitivity measures: 1) Barbour et al. (1996) method, 2) Discrimination Efficiency (DE), and 3) Balanced Discrimination Efficiency (BDE). 
```{r}
sensitivity.df <- sensitivity(metrics.long,
                              metric.col = metric,
                              value.col = value,
                              condition.col = lake,
                              ref.cond = "onon",
                              deg.cond = "caz")

DT::datatable(sensitivity.df, options = list(scrollX = TRUE))
```

# Plotting

Plot Barbour et al. (1996) values greater than or equal to 2.
```{r}
sensitivity.df %>% 
  filter(barbour >= 2) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(lake != "ot") %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 4)
```

Plot the top 10 metrics with the best DE values.
```{r, fig.width=10}
sensitivity.df %>% 
  arrange(desc(de)) %>% 
  slice(1:10) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(lake != "ot") %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 5, scale = "free")
```

Plot the top 10 metrics with the best BDE values.
```{r, fig.width= 10}
sensitivity.df %>% 
  arrange(desc(bde)) %>% 
  slice(1:10) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(lake != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) +
  facet_wrap(~metric, ncol = 5, scale = "free")
```

Plot an individual metric.
```{r}
sensitivity.df %>% 
  filter(metric == "rich_ephemeroptera") %>% 
  inner_join(metrics.long, by = "metric") %>% 
  filter(lake != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) 
```


