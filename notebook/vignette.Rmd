---
title: "Introduction to mmir: DRAFT"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
author: Zachary M. Smith
---
`r format(Sys.Date(), "%m-%d-%Y")`

# Overview

This document was created to provide an example of how to develop an MMI or IBI using the __mmir__ R-package.

# Preparation

Install the __tidyverse__ packages developed by R Studio. This is a collection of packages that make it easier to import, manipulate, and plot data. The package, __devtools__, must be installed to use the `devtools::install_github()` function. You will also need to install the __DT__ package if you want to create the interactive tables found below.
```{r, eval=FALSE}
install.packages("tidyverse", "devtools", "DT")
```

Only the __tidyverse__ packages will be loaded into the environment to avoid any potential conflicts. The majority of functions in this document will be called using `::`. A package is specified on the left side of `::` and a function within that package is specified to the right of `::` (`package::function()`). For example, `dplyr::filter()` specifies that we are using the `filter()` function from the __dplyr__ package and not the `filter()` function from the __stats__ package. It is generally not necessary to use `::` in your own scripts but in this document I hope it clarifies where the function comes from and aids in your understanding of the script.
```{r, messages=FALSE, warning=FALSE}
suppressPackageStartupMessages(
  library(tidyverse)
)
```

Install the Multi-Metric Index (MMI) package, __mmir__, that I am developing from Git Hub.  Make sure you install the development version of __mmir__ (`ref = "dev"`).
```{r, eval=FALSE}
devtools::install_github("zsmith27/mmir", ref = "dev", force = TRUE, quiet = TRUE)
```

Once __mmir__ is installed, load the packages with `library()`.
```{r}
library(mmir)
```

# Calculate Metrics

One of the major goals of the __mmir__ package was to simplify the metric calculation procedure. Five base taxa functions (i.e., `taxa_rich()`, `taxa_pct_rich()`, `taxa_div()`, `taxa_pct()`, and `taxa_abund()`) are capable of calculating the majority of metrics that are used in Multi-Metric Indices of biotic integrity. 

## Preparation

__mmir__ contains my thesis data, _onondaga_, as an example data set. My thesis compared the litoral benthic macorinvertebrate community in a recoverying preturbed lake, Onondaga Lake, to the communities found in two, less disturbed local lakes (i.e., Otisco and Cazenovia Lake). Sixteen stations were sampled within each lake (`station_id`) and two samples were collected at each site (`sample_number`).

This data is not ideal for this example because it was not collected with the intention of developing an MMI. However, this is the only data set that I have the right to make publicly available. Additionally, the Onondaga Lake samples can effectively represent a set of Degraded sites and the Cazenovia Lake samples can effectively represent Reference sites.
```{r}
data("onondaga", package = "mmir")
```

Create a data frame that will store the calculated metrics. This should include a unique site ID and possibly a few other important columns, such as stream gradient classification column (e.g., Reference and Degraded). I recommend not carrying all of the site information through the metric calculation process because it can easily be appended at the end of the calculation process or at another later step. This will reduce clutter, allowing you to focus on the metric values, and will help you manage memory allocation. Additionally, do __NOT__ alter the order of the unique identifier. The output from each metric function is a vector in the order of the supplied data frame of taxonomic counts (in this case `onondaga`). If the unique identifier is rearranged, no error will appear but the metric values will be associated with incorrect unique identifier.
```{r}
nest.df <- onondaga %>% 
  group_nest(unique_id, .key = "data") 
```

## Input Variable Definitions

Standard input variable definitions for functions in the __mmir__ package.

* `.data` = A data frame in a long data format, where each row represents a unique sampling event and taxon.
* `key.col` = A single column that represents a unique ID or key (i.e., site ID) that can be used to group the data. This variable should be input using NSE syntax (i.e., not quoted).
* `.group_col` = A single column that represents a lower resolution taxonomic rank than the taxonomic rank specified for `taxa.col`. This variable should be input using NSE syntax (i.e., not quoted).
* `taxa.col` = A single column that represents a higher resolution taxonomic rank than the taxonomic rank specified for `.group_col`. This variable should be input using NSE syntax (i.e., not quoted).
* `taxon` = A object or vector, generally a character string or a character vector, that is used subsets the data frame to only include rows that match the string(s) in `taxa.col`.
* `.counts_col` = A single numeric column that represents taxonomic counts. This variable should be input using NSE syntax (i.e., not quoted).

## Richness Metrics

Richness refers to the number of unique taxa. Typically, richness is used to refer to the number of unique species found in a sample but richness can be calculated for any taxonomic rank (e.g., order, family, genus).

### Community Richness

`taxa_rich()` is used to calculate richness. A long format data frame containing taxonomic counts is specified as the `.data` variable (`onondaga`). The name of a unique ID column is specified for the `.key_col` variable (`unique_id`). Note that this is done with NSE syntax (i.e., no quotes). The `.group_col` and `.filter_col` refer to low resolution and high resolution taxonomic rank columns of interest. `.filter_col` is required but `.group_col` is only necessary when calculating subgroup richness. Furthermore, the `taxon` variable is only necessary for specifying which taxon or taxa will be used to calculate subgroup richness; therefore, when calculating community richness, `taxon` should be set to `NULL`. In this example family-level and genus-level community richness are calculated and appended to `metrics.key`. `DT::datatable()` is only used to present interactive tables in this document.
```{r}
nest.df <- nest.df %>% 
  dplyr::mutate(
    rich_family = taxa_rich(.data = .,
                            .key_col = unique_id,
                            .group_col = family,
                            .unnest_col = data),
    rich_genus = taxa_rich(.data = .,
                            .key_col = unique_id,
                            .group_col = genus,
                            .unnest_col = data)
  )

DT::datatable(nest.df, options = list(scrollX = TRUE))  
```

### Subgroup Richness

`taxa_rich()` can also be used to calculate subgroup richness, which refers to calculating the richness of only select set of taxa. In the example below Ephemeroptera (Mayfly) richness is calculated at the family- and genus-levels. More than one taxonomic group can be specified, as shown for `rich_ept_gen` (`taxon = c("ephemeroptera", "plecoptera", "trichoptera")`). The `taxon` variable is used to filter the data frame based on character string matches found in specified `.group_col`. In the example, the `onondaga` data frame is subset to only include rows where the `order` column specifies "ephemeroptera". The `.filter_col` (e.g., `family` or `genus`) is then used to find the number of unique ephemeroptera taxa at this specified taxonomic level. If `taxon` was set to "baetidae" (a family of ephmeroptera) in the example below, then `taxa_rich()` would return all zeros because the character string "baetidae" would never be found in the order-level column.
```{r}
nest.df <- nest.df %>% 
  dplyr::mutate(
    rich_ephemeroptera_fam = taxa_rich(.data = .,
                            .key_col = unique_id,
                            .group_col = family,
                            .filter_col = order,
                            .filter_vec = "ephemeroptera",
                            .unnest_col = data),
    rich_ephemeroptera_gen = taxa_rich(.data = .,
                            .key_col = unique_id,
                            .group_col = genus,
                            .filter_col = order,
                            .filter_vec = "ephemeroptera",
                            .unnest_col = data),
    rich_ept_gen = taxa_rich(.data = .,
                            .key_col = unique_id,
                            .group_col = genus,
                            .filter_col = order,
                            .filter_vec = c("ephemeroptera", "plecoptera", "trichoptera"),
                            .unnest_col = data)
  )

DT::datatable(nest.df, options = list(scrollX = TRUE))  
```

## Diversity Metrics

Diversity metric in general combine the measure of taxonomic evenness and taxonomic richness. __ADD EVENNESS DESCRIPTION__.
A number of diversity metrics can be calculated using `taxa_div()`: _Shannon-Wiener Diversity_ ("shannon"), _Simpson's Diversity_ ("simpson"), _Margalef's Diversity_ ("margalef"), _Menhinick's Diversity_ ("menhinick"), and _Pielou Evenness_ ("pielou").

### Community Diversity


```{r}
nest.df <- nest.df %>% 
  dplyr::mutate(
    shannon_genus = taxa_div(.data = .,
                            .key_col = unique_id,
                            .counts_col = reporting_value,
                            .group_col = NULL,
                            .filter_col = genus,
                            job = "shannon",
                             base.log = 2,
                            .unnest_col = data),
    simpson_genus = taxa_div(.data = .,
                            .key_col = unique_id,
                            .counts_col = reporting_value,
                            .group_col = NULL,
                            .filter_col = genus,
                            job = "simpson",
                            .unnest_col = data),
    # margalef_genus = taxa_div(.data = .,
    #                         .key_col = unique_id,
    #                         .counts_col = reporting_value,
    #                         .group_col = NULL,
    #                         .filter_col = genus,
    #                         job = "margalef",
    # #                         .unnest_col = data),
    # menhinick_genus = taxa_div(.data = .,
    #                         .key_col = unique_id,
    #                         .counts_col = reporting_value,
    #                         .group_col = NULL,
    #                         .filter_col = genus,
    #                         job = "menhinick",
    #                         .unnest_col = data),
    pielou_genus = taxa_div(.data = .,
                            .key_col = unique_id,
                            .counts_col = reporting_value,
                            .group_col = NULL,
                            .filter_col = genus,
                            job = "pielou",
                            .unnest_col = data)
  )

DT::datatable(nest.df, options = list(scrollX = TRUE))  
```

### Subgroup Diversity

```{r, eval=FALSE}
nest.df <- nest.df %>% 
  dplyr::mutate(
    gini_simpson_ept = taxa_div(.data = .,
                            .key_col = unique_id,
                            .counts_col = reporting_value,
                            .group_col = order,
                            .filter_col = genus,
                            .filter_vec = c("ephemeroptera", "plecoptera", "trichoptera"),
                            job = "gini_simpson",
                            .unnest_col = data),
    simpson_ept = taxa_div(.data = .,
                            .key_col = unique_id,
                            .counts_col = reporting_value,
                            .group_col = order,
                            .filter_col = genus,
                            .filter_vec = c("ephemeroptera", "plecoptera", "trichoptera"),
                            job = "simpson",
                            .unnest_col = data),
    shannon_ept = taxa_div(.data = .,
                            .key_col = unique_id,
                            .counts_col = reporting_value,
                            .group_col = order,
                            .filter_col = genus,
                            .filter_vec = c("ephemeroptera", "plecoptera", "trichoptera"),
                            job = "shannon",
                            base.log = 2,
                            .unnest_col = data)
  )

DT::datatable(subdiv.df, options = list(scrollX = TRUE))  
```

## Community Metrics

### Percentages

`taxa_pct()` calculates the percentage of the sample represented by a taxon or taxa. The example below shows how to calculate the percentage of a single taxon, Ephemeroptera (`pct_ephemeroptera`), and multiple taxa, EPT (`pct_ept`). Remember that `.filter_col` refers to the name of the column that contains the taxon or taxa of interest. The `.filter_vec` variable is then used to specify these taxon or taxa.
```{r}
pct.df <- nest.df %>% 
  dplyr::mutate(
    pct_ephemeroptera = taxa_pct(.data = .,
                                  .key_col = unique_id,
                                  .counts_col = reporting_value,
                                  .filter_col = order,
                                  .filter_vec = "ephemeroptera"),
    pct_ept = taxa_pct(.data = .,
                        .key_col = unique_id,
                        .counts_col = reporting_value,
                        .filter_col = order,
                        .filter_vec = c("ephemeroptera", "plecoptera", "trichoptera"))
  )

DT::datatable(pct.df, options = list(scrollX = TRUE))  
```

### Abundances

Abundance refers to reported taxonomic count but may represent counts aggregated at a lower resolution taxonomic rank. For example, taxa may be reported at the genus-level but abundance could be calculated at the order-level. Generally, I have not found abundance metrics used in macorinvertebrate indices but they are common in fish indices. `taxa_abund()` has the same input as `taxa_pct()` (See [Percentages]).
```{r}
nest.df <- nest.df %>% 
  dplyr::mutate(
    abund_ephemeroptera = taxa_abund(.,
                                  .key_col = unique_id,
                                  .counts_col = reporting_value,
                                  .filter_col = order,
                                  .filter_vec = "ephemeroptera"),
    abund_ept = taxa_abund(.,
                        .key_col = unique_id,
                        .counts_col = reporting_value,
                        .filter_col = order,
                        .filter_vec = c("ephemeroptera", "plecoptera", "trichoptera"))
  )

DT::datatable(nest.df, options = list(scrollX = TRUE))  
```

## Sequencing Metric Calculations

When developing a new index, the developer usually tries to evaluate as many metrics as possible to obtain the most sensitive metrics. Writing individual lines of code for each taxon using `taxa_rich()`, `taxa_pct_rich()`, `taxa_pct()`, or `taxa_abund()` would be very time consuming and prone to typos. `taxa_seq()` was developed to make these calculations simple and safe. 

This is a wrapper function around the previously discussed taxa metrics (`taxa_rich()`, `taxa_pct_rich()`, `taxa_pct()`, or `taxa_abund()`), which loops through each taxon in the specified taxonomic rank or taxonomic attribute column(s) calculating taxon richness, taxon percent richness, taxon percentages, or taxon abundance. The input variable, `job`, is used to specify which type of metrics to calculate (i.e., "rich", "pct_rich", "pct", and "abund"). The character string used to specify the `job` will be used as a prefix for the column names (e.g., "rich_ephemeroptera" or "pct_plecoptera"). The remaining inputs are the same as the base taxa functions (`taxa_rich()`, `taxa_pct_rich()`, `taxa_pct()`, or `taxa_abund()`) that `taxa_seq()` wraps around. This also means that there will frequently be many input variables that you do not need to use. For example, if `job = "pct"`, then `hich.taxa.col`, `base.log`, and `q` do not need to be specified because these variables are only used for richness and/or diversity related calculations. It is often helpful to refer back to the base taxa function to identify the necessary inputs for the specified job. Additionally, each metric only represents a single taxon. The output will therefore not include metrics, such as the percentage of EPT taxa or the richness of Gathers' and Filter Feeder taxa. These metrics will need to be calculated individually using the base taxa functions.

The example below calculates taxa richness, percent taxa richness, taxa percentage, and taxa abundance for all of the taxa under the order and family columns. The `taxa.cols` input variable could be reduced to just one column (`taxa.cols = "family"`) or could be expanded to include as many taxonomic rank and/or taxonomic attribute columns as you want (`taxa.cols = c("class", order", "suborder", "family", "tolerance_values", "functional_feeding_groups", "habits")`). I suggest specifying all of your taxonomic rank and taxonomic attribute columns. This will create a lot of output, could potentially take awhile to calculate, and the majority of the metrics will have very poor metric sensitivity; however, the `sensitivity()` function (See [Calculate Metric Sensitivity]) will allow you to quickly filter out poorly performing metrics. Calculating a large amount of metrics will give you more opptertunities to identify patterns that reflect your defined disturbance gradient. I used this function during the development of the Chessie BIBI and I found several metrics that are not commonly used to have high metric sensitivity values. For example, the percent of Systellognatha (a suborder of Plecoptera) was more sensitive than the commonly used percent of Plecoptera metric. This extensive exploration of your data also comes with the danger of overfitting your index. To prevent this issue please use index validation procedure (e.g., Hold-Out validation or Cross Validation) during your index development.
```{r}
seq.df <- nest.df %>% 
  bind_cols(
    taxa_seq(.data = .,
             .key_col = unique_id,
             .group_col = family,
             .filter_col = 
             .unnest_col = data))
    taxa_seq(onondaga,
             unique_id,
             reporting_value,
             c("order", "family"),
             "genus",
             job = "rich"),
    taxa_seq(onondaga,
             unique_id,
             reporting_value,
             c("order", "family"),
             "genus",
             job = "pct_rich"),
    taxa_seq(onondaga, unique_id, reporting_value, c("order", "family"),  job = "pct"),
    taxa_seq(onondaga, unique_id, reporting_value, c("order", "family"),  job = "abund")
  )

DT::datatable(seq.df, options = list(scrollX = TRUE))  
```

## Run All Metrics

Below is an example of how to put all of the metrics together into a single data frame. When calculating so many metrics I recommend breaking the script into chunks, as was done above, becuase it can be difficult to debug one large code chunk. Imagine all of the script above crammed into one `dplyr::bind_cols()` call. `plyr::join_all()` allows multiple data frames with the same key(s) to be joined at once. This function just requires that the various data frames be in a list format for the input but the output is a single data frame. `by` refers to the key column(s).

The metrics `pct_ephemeroptera` and `abund_ephemeroptera` are duplicated from the `taxa_pct()`, `taxa_abund()`, and `taxa_seq()` examples. Therefore, `dplyr::select()` is used to remove these columns from `pct.df` and `abund.df`
```{r}
metrics.wide <-  list(rich.df,
                      div.df, 
                      # subdiv.df,
                      select(pct.df, -pct_ephemeroptera),
                      select(abund.df, -abund_ephemeroptera),
                      seq.df) %>% 
  plyr::join_all(by = c("unique_id", "lake"))
```

# Metric Sensitivity


## Long Data Transformation

If you followed the steps above your metrics are stored in a wide data format (see `metrics.wide`); however, to simplify the metric sensitivity calculations the data needs to be transformed to a long data format. This can be easily done with the __tidyr__ (installed and loaded with __tidyverse__) function, `tidyr::gather()`. The first input variable refers to the wide data frame (`metrics.wide`). The second input specifies the name of column that will hold the current column names. The third input specifies the name of the column that will hold the values from each column. At the end of the function the key column(s) need to be dropped (`-unique_id, -lake`).
```{r}
metrics.long <- tidyr::gather(metrics.wide, metric, value, -unique_id, -lake)

DT::datatable(head(metrics.long, 500), options = list(scrollX = TRUE))
```

## Calculate Metric Sensitivity

Barbour et al. (1996) created a visual method for evaluating metric response to a defined disturbance gradient.

* 0 = The medians of both the reference and degraded conditions overlap the interquartile range of one another.
* 1 = One median (either the reference or degraded) overlaps the interquartile range of the other.
* 2 = The interquartile ranges of the reference and degraded conditions overlap but neither conditions median overlaps with the interquartile range of the other category.
* 3 = The interquartile ranges of the reference and degraded conditions do not overlap.

Discrimination Efficiency (DE) is a measure of the percentage of degraded samples correctly identified below the reference distributions 25th percentile for metrics that decrease with degradation or the percentage of degraded samples correctly identified above the reference distributions 75th percentile for metrics that increase with disturbance.

Balanced Discrimination Efficiency (BDE) attempts to update the DE method by throwing more computation power at the problem. BDE tests multiple thresholds for separating the reference and degraded distributions in an attempt to find the best separation point.

Use the `sensitivity()` function to calculate three types of metric sensitivity measures: 1) Barbour et al. (1996) method, 2) Discrimination Efficiency (DE), and 3) Balanced Discrimination Efficiency (BDE). 
```{r}
sensitivity.df <- sensitivity(metrics.long,
                              metric.col = metric,
                              value.col = value,
                              condition.col = lake,
                              ref.cond = "onon",
                              deg.cond = "caz")

DT::datatable(sensitivity.df, options = list(scrollX = TRUE))
```

# Plotting

Plot Barbour et al. (1996) values greater than or equal to 2.
```{r, fig.width=8, fig.height=10}
sensitivity.df %>% 
  filter(barbour == 3) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(lake != "ot") %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 4, scales = "free")
```

Plot the top 10 metrics with the best DE values.
```{r, fig.width=10}
sensitivity.df %>% 
  arrange(desc(de)) %>% 
  slice(1:10) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(lake != "ot") %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 5, scale = "free")
```

Plot the top 10 metrics with the best BDE values.
```{r, fig.width= 10}
sensitivity.df %>% 
  arrange(desc(bde)) %>% 
  slice(1:10) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(lake != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(lake, value)) +
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) +
  facet_wrap(~metric, ncol = 5, scale = "free")
```

Plot an individual metric.
```{r}
sensitivity.df %>% 
  filter(metric == "pct_rich_heptageniidae") %>% 
  inner_join(metrics.long, by = "metric") %>% 
  filter(lake != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(lake, value)) +
  geom_jitter()+
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) 
```


```{r}
sensitivity.df %>% 
  filter(metric == "pct_ept") %>% 
  inner_join(metrics.long, by = "metric") %>% 
  filter(lake != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(lake, value)) +
  geom_jitter()+
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) 
```
